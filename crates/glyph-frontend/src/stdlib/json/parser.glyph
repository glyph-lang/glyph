// Minimal JSON Parser - Uses only basic Glyph syntax

from std/json import JsonValue, ParseError, ParseResult
from std/enums import Option
from std/map import Map
from std/string import byte_at, atof, string_from_byte
from std/vec import Vec

struct ParsedValue {
  value: JsonValue,
  next: usize,
}

struct ParsedString {
  value: String,
  next: usize,
}

struct ParsedHex {
  value: i32,
  ok: i32,
}

fn make_parse_error(msg: String, pos: usize) -> ParseError {
  ret ParseError { message: msg, position: pos }
}

fn parsed_string_to_json_value(p: ParsedString) -> ParsedValue {
  let next = p.next
  let s = p.value
  ret ParsedValue { value: JsonValue::String(s), next: next }
}

fn skip_ws(input: str, pos0: usize) -> usize {
  let mut pos = pos0
  let len = input.len()
  while pos < len {
    let ch = byte_at(input, pos)
    // space, tab, CR, LF
    if ch == 32 || ch == 9 || ch == 13 || ch == 10 {
      pos = pos + 1
    } else {
      ret pos
    }
  }
  ret pos
}

fn is_digit(ch: u8) -> bool {
  ret ch >= 48 && ch <= 57
}

fn hex_value(ch: u8) -> i32 {
  if ch >= 48 && ch <= 57 {
    ret ch - 48
  }
  if ch >= 65 && ch <= 70 {
    ret ch - 55
  }
  if ch >= 97 && ch <= 102 {
    ret ch - 87
  }
  ret 0 - 1
}

fn parse_hex4(input: str, pos: usize) -> ParsedHex {
  let len = input.len()
  if pos + 3 >= len {
    ret ParsedHex { value: 0, ok: 0 }
  }
  let d0 = hex_value(byte_at(input, pos))
  if d0 < 0 {
    ret ParsedHex { value: 0, ok: 0 }
  }
  let d1 = hex_value(byte_at(input, pos + 1))
  if d1 < 0 {
    ret ParsedHex { value: 0, ok: 0 }
  }
  let d2 = hex_value(byte_at(input, pos + 2))
  if d2 < 0 {
    ret ParsedHex { value: 0, ok: 0 }
  }
  let d3 = hex_value(byte_at(input, pos + 3))
  if d3 < 0 {
    ret ParsedHex { value: 0, ok: 0 }
  }
  let code = d0 * 4096 + d1 * 256 + d2 * 16 + d3
  ret ParsedHex { value: code, ok: 1 }
}

fn rem_64(value: i32) -> i32 {
  ret value - (value / 64) * 64
}

fn push_utf8_codepoint(segments0: Vec<String>, code: i32) -> Vec<String> {
  let mut segments = segments0
  if code <= 127 {
    segments.push(string_from_byte(code))
    ret segments
  }
  if code <= 2047 {
    let hi = code / 64
    let lo = rem_64(code)
    let b1 = 192 + hi
    let b2 = 128 + lo
    segments.push(string_from_byte(b1))
    segments.push(string_from_byte(b2))
    ret segments
  }
  if code <= 65535 {
    let mid = code / 64
    let b1 = 224 + (code / 4096)
    let b2 = 128 + rem_64(mid)
    let b3 = 128 + rem_64(code)
    segments.push(string_from_byte(b1))
    segments.push(string_from_byte(b2))
    segments.push(string_from_byte(b3))
    ret segments
  }
  if code <= 1114111 {
    let mid1 = code / 4096
    let mid2 = code / 64
    let b1 = 240 + (code / 262144)
    let b2 = 128 + rem_64(mid1)
    let b3 = 128 + rem_64(mid2)
    let b4 = 128 + rem_64(code)
    segments.push(string_from_byte(b1))
    segments.push(string_from_byte(b2))
    segments.push(string_from_byte(b3))
    segments.push(string_from_byte(b4))
    ret segments
  }
  ret segments
}

fn parse_literal(input: str, pos: usize, lit: str) -> bool {
  let lit_len = lit.len()
  let in_len = input.len()
  if pos + lit_len > in_len {
    ret false
  }

  let i0 = 0
  ret parse_literal_loop(input, pos, lit, lit_len, i0)
}

fn parse_literal_loop(input: str, pos: usize, lit: str, lit_len: usize, i: usize) -> bool {
  if i >= lit_len {
    ret true
  }
  if byte_at(input, pos + i) != byte_at(lit, i) {
    ret false
  }
  ret parse_literal_loop(input, pos, lit, lit_len, i + 1)
}

fn parse_number(input: str, pos: usize) -> ParseResult<ParsedValue> {
  let len = input.len()
  let mut i = pos
  if i < len && byte_at(input, i) == 45 {
    i = i + 1
  }

  if i >= len {
    ret Err(ParseError { message: String::from_str("expected digit"), position: i })
  }
  if is_digit(byte_at(input, i)) {
    // ok
  } else {
    ret Err(ParseError { message: String::from_str("expected digit"), position: i })
  }

  i = parse_digits(input, len, i)

  // fraction
  if i < len && byte_at(input, i) == 46 {
    i = i + 1
    if i >= len {
      ret Err(ParseError { message: String::from_str("expected digit after '.'"), position: i })
    }
    if is_digit(byte_at(input, i)) {
      // ok
    } else {
      ret Err(ParseError { message: String::from_str("expected digit after '.'"), position: i })
    }
    i = parse_digits(input, len, i)
  }

  // exponent (subset)
  if i < len {
    let e = byte_at(input, i)
    if e == 101 || e == 69 {
      i = i + 1
      if i < len {
        let s = byte_at(input, i)
        if s == 43 || s == 45 {
          i = i + 1
        }
      }
      if i >= len {
        ret Err(ParseError { message: String::from_str("expected digit in exponent"), position: i })
      }
      if is_digit(byte_at(input, i)) {
        // ok
      } else {
        ret Err(ParseError { message: String::from_str("expected digit in exponent"), position: i })
      }
      i = parse_digits(input, len, i)
    }
  }

  let slice = input.slice(pos, i - pos)
  let n = atof(slice)
  ret Ok(ParsedValue { value: JsonValue::Number(n), next: i })
}

fn parse_digits(input: str, len: usize, i0: usize) -> usize {
  if i0 >= len {
    ret i0
  }
  if is_digit(byte_at(input, i0)) {
    // ok
  } else {
    ret i0
  }
  ret parse_digits(input, len, i0 + 1)
}

fn parse_string(input: str, pos: usize) -> ParseResult<ParsedString> {
  let len = input.len()
  if pos >= len || byte_at(input, pos) != 34 {
    ret Err(make_parse_error(String::from_str("expected string"), pos))
  }
  let mut i = pos + 1
  let mut seg_start = i
  let mut had_escape = false
  let mut segments: Vec<String> = Vec::new()

  while i < len {
    let ch = byte_at(input, i)
    if ch == 34 {
      if had_escape == false {
        let s = input.slice(pos + 1, i - (pos + 1))
        ret Ok(ParsedString { value: s, next: i + 1 })
      }
      if seg_start < i {
        let tail = input.slice(seg_start, i - seg_start)
        segments.push(tail)
      }
      let s = concat_segments(segments)
      ret Ok(ParsedString { value: s, next: i + 1 })
    }

    if ch < 32 {
      ret Err(make_parse_error(String::from_str("unescaped control character"), i))
    }

    if ch == 92 {
      had_escape = true
      if seg_start < i {
        let part = input.slice(seg_start, i - seg_start)
        segments.push(part)
      }

      if i + 1 >= len {
        ret Err(make_parse_error(String::from_str("unterminated escape"), i))
      }

      let next = byte_at(input, i + 1)
      if next == 34 {
        segments.push(string_from_byte(34))
        i = i + 2
        seg_start = i
        cont
      }
      if next == 92 {
        segments.push(string_from_byte(92))
        i = i + 2
        seg_start = i
        cont
      }
      if next == 47 {
        segments.push(string_from_byte(47))
        i = i + 2
        seg_start = i
        cont
      }
      if next == 98 {
        segments.push(string_from_byte(8))
        i = i + 2
        seg_start = i
        cont
      }
      if next == 102 {
        segments.push(string_from_byte(12))
        i = i + 2
        seg_start = i
        cont
      }
      if next == 110 {
        segments.push(string_from_byte(10))
        i = i + 2
        seg_start = i
        cont
      }
      if next == 114 {
        segments.push(string_from_byte(13))
        i = i + 2
        seg_start = i
        cont
      }
      if next == 116 {
        segments.push(string_from_byte(9))
        i = i + 2
        seg_start = i
        cont
      }

      if next == 117 {
        let esc_pos = i
        let hex = parse_hex4(input, i + 2)
        if hex.ok == 0 {
          ret Err(make_parse_error(String::from_str("invalid unicode escape"), esc_pos))
        }
        let code: i32 = hex.value

          if code == 0 {
            ret Err(make_parse_error(String::from_str("nul escape unsupported"), esc_pos))
          }

        if code >= 55296 && code <= 56319 {
          if i + 11 >= len {
            ret Err(make_parse_error(String::from_str("invalid unicode surrogate"), esc_pos))
          }
          if byte_at(input, i + 6) != 92 || byte_at(input, i + 7) != 117 {
            ret Err(make_parse_error(String::from_str("invalid unicode surrogate"), esc_pos))
          }

          let low_hex = parse_hex4(input, i + 8)
          if low_hex.ok == 0 {
            ret Err(make_parse_error(String::from_str("invalid unicode escape"), esc_pos))
          }
          let low: i32 = low_hex.value
          if low < 56320 || low > 57343 {
            ret Err(make_parse_error(String::from_str("invalid unicode surrogate"), esc_pos))
          }

          let high: i32 = code - 55296
          let low_adj: i32 = low - 56320
          let codepoint: i32 = 65536 + (high * 1024) + low_adj
          segments = push_utf8_codepoint(segments, codepoint)
          i = i + 12
          seg_start = i
          cont
        }

        if code >= 56320 && code <= 57343 {
          ret Err(make_parse_error(String::from_str("invalid unicode surrogate"), esc_pos))
        }

        segments = push_utf8_codepoint(segments, code)
        i = i + 6
        seg_start = i
        cont
      }

      ret Err(make_parse_error(String::from_str("invalid escape"), i))
    }

    i = i + 1
  }

  ret Err(make_parse_error(String::from_str("unterminated string"), pos))
}

fn concat_segments(segments0: Vec<String>) -> String {
  let mut segments = segments0
  if segments.len() == 0 {
    ret String::from_str("")
  }

  while segments.len() > 1 {
    let mut next: Vec<String> = Vec::new()

    while segments.len() > 1 {
      let right = segments.pop()
      let left = segments.pop()
      let merged = match left {
        Some(l) => match right {
          Some(r) => l.concat(r),
          None => l,
        },
        None => String::from_str(""),
      }
      next.push(merged)
    }

    let leftover = segments.pop()
    match leftover {
      Some(s) => next.push(s),
      None => {},
    }

    segments = reverse_segments(next)
  }

  let out = segments.pop()
  ret match out {
    Some(s) => s,
    None => String::from_str(""),
  }
}

fn reverse_segments(input: Vec<String>) -> Vec<String> {
  let mut src = input
  let mut out: Vec<String> = Vec::new()
  while src.len() > 0 {
    let v = src.pop()
    match v {
      Some(s) => out.push(s),
      None => {},
    }
  }
  ret out
}

fn parse_array(input: str, pos: usize) -> ParseResult<ParsedValue> {
  let len = input.len()
  if pos >= len || byte_at(input, pos) != 91 {
    ret Err(ParseError { message: String::from_str("expected '['"), position: pos })
  }

  let mut i = skip_ws(input, pos + 1)
  let mut arr: Vec<JsonValue> = Vec::new()

  if i < len && byte_at(input, i) == 93 {
    ret Ok(ParsedValue { value: JsonValue::Array(arr), next: i + 1 })
  }

  ret parse_array_elems(input, len, i, arr)
}

fn parse_array_elems(input: str, len: usize, i0: usize, arr0: Vec<JsonValue>) -> ParseResult<ParsedValue> {
  let pv = parse_value(input, i0)
  ret match pv {
    Ok(p) => parse_array_after_value(input, len, p, arr0),
    Err(e) => Err(e),
  }
}

fn parse_array_after_value(
  input: str,
  len: usize,
  parsed: ParsedValue,
  arr0: Vec<JsonValue>,
) -> ParseResult<ParsedValue> {
  let mut arr = arr0
  let next = parsed.next
  arr.push(parsed.value)
  let mut i = skip_ws(input, next)

  if i >= len {
    ret Err(ParseError { message: String::from_str("unterminated array"), position: i })
  }

  let ch = byte_at(input, i)
  if ch == 44 {
    i = skip_ws(input, i + 1)
    ret parse_array_elems(input, len, i, arr)
  }

  if ch == 93 {
    ret Ok(ParsedValue { value: JsonValue::Array(arr), next: i + 1 })
  }

  ret Err(ParseError { message: String::from_str("expected ',' or ']'"), position: i })
}

fn parse_object(input: str, pos: usize) -> ParseResult<ParsedValue> {
  let len = input.len()
  if pos >= len || byte_at(input, pos) != 123 {
    ret Err(ParseError { message: String::from_str("expected '{'"), position: pos })
  }

  let mut i = skip_ws(input, pos + 1)
  let mut obj: Map<String, JsonValue> = Map::new()

  if i < len && byte_at(input, i) == 125 {
    ret Ok(ParsedValue { value: JsonValue::Object(obj), next: i + 1 })
  }

  ret parse_object_pairs(input, len, i, obj)
}

fn parse_object_pairs(input: str, len: usize, i0: usize, obj0: Map<String, JsonValue>) -> ParseResult<ParsedValue> {
  let pk = parse_string(input, i0)
  ret match pk {
    Ok(kparsed) => parse_object_after_key(input, len, kparsed, obj0),
    Err(e) => Err(e),
  }
}

fn parse_object_after_key(
  input: str,
  len: usize,
  kparsed: ParsedString,
  obj0: Map<String, JsonValue>,
) -> ParseResult<ParsedValue> {
  let mut i = skip_ws(input, kparsed.next)

  if i >= len || byte_at(input, i) != 58 {
    ret Err(ParseError { message: String::from_str("expected ':'"), position: i })
  }
  i = skip_ws(input, i + 1)

  let pv = parse_value(input, i)
  ret match pv {
    Ok(vparsed) => parse_object_after_value(input, len, kparsed.value, vparsed, obj0),
    Err(e) => Err(e),
  }
}

fn parse_object_after_value(
  input: str,
  len: usize,
  k: String,
  vparsed: ParsedValue,
  obj0: Map<String, JsonValue>,
) -> ParseResult<ParsedValue> {
  let mut obj = obj0
  let next_v = vparsed.next
  let _ = obj.add(k, vparsed.value)

  let mut i = skip_ws(input, next_v)
  if i >= len {
    ret Err(ParseError { message: String::from_str("unterminated object"), position: i })
  }

  let ch = byte_at(input, i)
  if ch == 44 {
    i = skip_ws(input, i + 1)
    ret parse_object_pairs(input, len, i, obj)
  }

  if ch == 125 {
    ret Ok(ParsedValue { value: JsonValue::Object(obj), next: i + 1 })
  }

  ret Err(ParseError { message: String::from_str("expected ',' or '}'"), position: i })
}

fn parse_value(input: str, pos0: usize) -> ParseResult<ParsedValue> {
  let pos = skip_ws(input, pos0)
  let len = input.len()
  if pos >= len {
    ret Err(ParseError { message: String::from_str("unexpected end of input"), position: pos })
  }

  if parse_literal(input, pos, "null") {
    ret Ok(ParsedValue { value: JsonValue::Null(), next: pos + 4 })
  }
  if parse_literal(input, pos, "true") {
    ret Ok(ParsedValue { value: JsonValue::Bool(true), next: pos + 4 })
  }
  if parse_literal(input, pos, "false") {
    ret Ok(ParsedValue { value: JsonValue::Bool(false), next: pos + 5 })
  }

  let ch = byte_at(input, pos)
  if ch == 34 {
    let ps = parse_string(input, pos)
    ret match ps {
      Ok(p) => Ok(parsed_string_to_json_value(p)),
      Err(e) => Err(e),
    }
  }

  if ch == 91 {
    ret parse_array(input, pos)
  }

  if ch == 123 {
    ret parse_object(input, pos)
  }

  if ch == 45 || is_digit(ch) {
    ret parse_number(input, pos)
  }

  ret Err(ParseError { message: String::from_str("unexpected token"), position: pos })
}

fn parse(input: str) -> ParseResult<JsonValue> {
  let pv = parse_value(input, 0)
  ret match pv {
    Ok(p) => parse_finish(input, p),
    Err(e) => Err(e),
  }
}

fn parse_finish(input: str, parsed: ParsedValue) -> ParseResult<JsonValue> {
  let end = skip_ws(input, parsed.next)
  if end != input.len() {
    ret Err(ParseError { message: String::from_str("trailing characters"), position: end })
  }
  ret Ok(parsed.value)
}
